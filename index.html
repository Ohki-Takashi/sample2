<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>ãƒ†ãƒˆãƒªã‚¹</title>
  <style>
    body {
      text-align: center;
      font-family: sans-serif;
      background: #eee;
      margin: 0;
      padding: 20px;
    }
    /* å¤§ããã‚«ãƒ©ãƒ•ãƒ«ãªã€Œã‚²ãƒ¼ãƒ é–‹å§‹ã€ãƒœã‚¿ãƒ³ */
    #startButton {
      font-size: 20px;
      padding: 12px 24px;
      background: linear-gradient(to right, #ff7e5f, #feb47b);
      color: white;
      border: none;
      border-radius: 10px;
      cursor: pointer;
      transition: transform 0.2s ease, box-shadow 0.2s ease;
      margin-bottom: 10px;
    }
    #startButton:hover {
      transform: scale(1.1);
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
    }
    canvas {
      background: #000;
      display: block;
      margin: 10px auto;
      border: 2px solid #333;
    }
    #scoreBoard {
      font-size: 18px;
      margin-bottom: 10px;
    }
  </style>
</head>
<body>
  <button id="startButton">ã‚²ãƒ¼ãƒ é–‹å§‹</button>
  <div id="scoreBoard">
    Score: <span id="score">0</span>
    <span id="message" style="color: red;"></span>
  </div>
  <canvas id="gameCanvas" width="200" height="400"></canvas>
  <!-- ãƒ–ãƒ­ãƒƒã‚¯æ¶ˆæ»…æ™‚ã®åŠ¹æœéŸ³ -->
  <audio id="clearSound" src="https://actions.google.com/sounds/v1/alarms/beep_short.ogg"></audio>

  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const scoreElement = document.getElementById('score');
    const messageElement = document.getElementById('message');
    const startButton = document.getElementById('startButton');
    const clearSound = document.getElementById('clearSound');

    const COLS = 10;
    const ROWS = 20;
    const BLOCK_SIZE = 20;

    let board = [];
    let currentPiece;
    let gameInterval;
    let score = 0;
    let gameOver = false;
    // è½ä¸‹é€Ÿåº¦å¤‰æ›´æ¸ˆã¿ã‹ã®ãƒ•ãƒ©ã‚°ï¼ˆåˆæœŸã¯falseï¼‰
    let speedIncreased = false;

    // ãƒ†ãƒˆãƒªãƒŸãƒã®å½¢çŠ¶å®šç¾©
    const SHAPES = {
      I: [
        [0,0,0,0],
        [1,1,1,1],
        [0,0,0,0],
        [0,0,0,0]
      ],
      J: [
        [1,0,0],
        [1,1,1],
        [0,0,0]
      ],
      L: [
        [0,0,1],
        [1,1,1],
        [0,0,0]
      ],
      O: [
        [1,1],
        [1,1]
      ],
      S: [
        [0,1,1],
        [1,1,0],
        [0,0,0]
      ],
      T: [
        [0,1,0],
        [1,1,1],
        [0,0,0]
      ],
      Z: [
        [1,1,0],
        [0,1,1],
        [0,0,0]
      ]
    };

    const COLORS = {
      I: 'cyan',
      J: 'blue',
      L: 'orange',
      O: 'yellow',
      S: 'green',
      T: 'purple',
      Z: 'red'
    };

    // ãƒ©ãƒ³ãƒ€ãƒ ã«ãƒ†ãƒˆãƒªãƒŸãƒã‚’ç”Ÿæˆ
    function randomPiece() {
      const types = Object.keys(SHAPES);
      const type = types[Math.floor(Math.random() * types.length)];
      const shape = SHAPES[type];
      return {
        type: type,
        shape: shape,
        x: Math.floor((COLS - shape[0].length) / 2),
        y: 0
      };
    }

    // ã‚²ãƒ¼ãƒ ç›¤ã‚’åˆæœŸåŒ–
    function createBoard() {
      board = [];
      for (let r = 0; r < ROWS; r++) {
        board[r] = [];
        for (let c = 0; c < COLS; c++) {
          board[r][c] = '';
        }
      }
    }

    // ç›¤é¢æç”»
    function drawBoard() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          if (board[r][c]) {
            ctx.fillStyle = board[r][c];
            ctx.fillRect(c * BLOCK_SIZE, r * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
            ctx.strokeStyle = '#000';
            ctx.strokeRect(c * BLOCK_SIZE, r * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
          }
        }
      }
    }

    // ç¾åœ¨ã®ãƒ†ãƒˆãƒªãƒŸãƒæç”»
    function drawPiece(piece) {
      const shape = piece.shape;
      for (let r = 0; r < shape.length; r++) {
        for (let c = 0; c < shape[r].length; c++) {
          if (shape[r][c]) {
            ctx.fillStyle = COLORS[piece.type];
            ctx.fillRect((piece.x + c) * BLOCK_SIZE, (piece.y + r) * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
            ctx.strokeStyle = '#000';
            ctx.strokeRect((piece.x + c) * BLOCK_SIZE, (piece.y + r) * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
          }
        }
      }
    }

    // è¡çªåˆ¤å®š
    function isValidMove(piece, offsetX, offsetY, newShape = null) {
      const shape = newShape || piece.shape;
      for (let r = 0; r < shape.length; r++) {
        for (let c = 0; c < shape[r].length; c++) {
          if (shape[r][c]) {
            const newX = piece.x + c + offsetX;
            const newY = piece.y + r + offsetY;
            if (newX < 0 || newX >= COLS || newY >= ROWS) {
              return false;
            }
            if (newY >= 0 && board[newY][newX]) {
              return false;
            }
          }
        }
      }
      return true;
    }

    // ãƒ†ãƒˆãƒªãƒŸãƒã®å›è»¢
    function rotate(matrix) {
      const N = matrix.length;
      let result = [];
      for (let i = 0; i < N; i++) {
        result[i] = [];
        for (let j = 0; j < N; j++) {
          result[i][j] = matrix[N - j - 1][i];
        }
      }
      return result;
    }

    // ãƒ†ãƒˆãƒªãƒŸãƒã‚’ç›¤é¢ã«å›ºå®š
    function lockPiece(piece) {
      const shape = piece.shape;
      for (let r = 0; r < shape.length; r++) {
        for (let c = 0; c < shape[r].length; c++) {
          if (shape[r][c]) {
            // ç›¤é¢ä¸Šéƒ¨ã«é”ã—ã¦ã„ã‚‹å ´åˆã¯ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼
            if (piece.y + r < 0) {
              gameOver = true;
              return;
            }
            board[piece.y + r][piece.x + c] = COLORS[piece.type];
          }
        }
      }
    }

    // ãƒ©ã‚¤ãƒ³ã‚¯ãƒªã‚¢ã¨ã‚¹ã‚³ã‚¢æ›´æ–°ã€åŠ¹æœéŸ³å†ç”Ÿã€ãŠç¥ã„ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®è¡¨ç¤ºã€é€Ÿåº¦å¤‰æ›´
    function clearLines() {
      let linesCleared = 0;
      for (let r = ROWS - 1; r >= 0; r--) {
        if (board[r].every(cell => cell !== '')) {
          board.splice(r, 1);
          board.unshift(new Array(COLS).fill(''));
          linesCleared++;
          r++; // è¡ŒãŒã‚·ãƒ•ãƒˆã™ã‚‹ã®ã§å†ãƒã‚§ãƒƒã‚¯
        }
      }
      if (linesCleared > 0) {
        score += linesCleared * 10;
        scoreElement.textContent = score;
        clearSound.currentTime = 0;
        clearSound.play();

        // ã‚¹ã‚³ã‚¢300ä»¥ä¸Šãªã‚‰ã‚²ãƒ¼ãƒ ã‚¯ãƒªã‚¢
        if (score >= 300) {
          gameOver = true;
          showGameClear();
          return;
        }
        // ã‚¹ã‚³ã‚¢100ä»¥ä¸Šã§ã€ã¾ã é€Ÿåº¦å¤‰æ›´ã—ã¦ã„ãªã‘ã‚Œã°è½ä¸‹é€Ÿåº¦ã‚’æ—©ãã™ã‚‹
        if (score >= 100 && !speedIncreased) {
          speedIncreased = true;
          clearInterval(gameInterval);
          gameInterval = setInterval(gameLoop, 300);  // è½ä¸‹é€Ÿåº¦ã‚’æ—©ãï¼ˆä¾‹ï¼š300msï¼‰
          messageElement.textContent = "ã‚¹ãƒ”ãƒ¼ãƒ‰ã‚¢ãƒƒãƒ—ï¼";
          setTimeout(() => { messageElement.textContent = ""; }, 2000);
        }
        // 50ç‚¹ã”ã¨ã«ãƒ©ãƒ³ãƒ€ãƒ ãªãŠç¥ã„ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ï¼ˆãŸã ã—ã€100ç‚¹æ™‚ã¯é€Ÿåº¦å¤‰æ›´ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãŒå„ªå…ˆï¼‰
        else if (score % 50 === 0) {
          const congratsMessages = [
            "æœ€é«˜ã ã­ï¼",
            "ã‚¯ãƒ¼ãƒ«ã ã­ï¼",
            "è¼ã„ã¦ã‚‹ï¼",
            "ç´ æ™´ã‚‰ã—ã„ï¼",
            "çµ¶å¥½èª¿ï¼",
            "ã‚¤ã‚±ã¦ã‚‹ï¼",
            "ãƒ‘ãƒ¼ãƒ•ã‚§ã‚¯ãƒˆï¼"
          ];
          messageElement.textContent = congratsMessages[Math.floor(Math.random() * congratsMessages.length)];
          setTimeout(() => { messageElement.textContent = ""; }, 2000);
        }
      }
    }

    // ã‚²ãƒ¼ãƒ ã‚¯ãƒªã‚¢æ™‚ã®è¡¨ç¤º
    function showGameClear() {
      ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
      ctx.fillRect(0, canvas.height / 2 - 50, canvas.width, 100);
      ctx.fillStyle = '#FFF';
      ctx.font = '24px Arial';
      ctx.textAlign = 'center';
      ctx.fillText("ğŸ‰ ã‚²ãƒ¼ãƒ ã‚¯ãƒªã‚¢ï¼ ğŸ‰", canvas.width / 2, canvas.height / 2 - 10);
      ctx.font = '18px Arial';
      ctx.fillText("ğŸŒŸ ä¼èª¬ç´šã®ãƒ—ãƒ¬ã‚¤ï¼ ğŸŒŸ", canvas.width / 2, canvas.height / 2 + 20);
    }

    // ã‚²ãƒ¼ãƒ ãƒ«ãƒ¼ãƒ—
    function gameLoop() {
      if (gameOver) {
        clearInterval(gameInterval);
        // ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ã®å ´åˆã¯ã€ã‚¹ã‚³ã‚¢ãŒ300æœªæº€ãªã‚‰ Game Over è¡¨ç¤º
        if (score < 300) {
          ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
          ctx.fillRect(0, canvas.height / 2 - 30, canvas.width, 60);
          ctx.fillStyle = '#FFF';
          ctx.font = '20px Arial';
          ctx.textAlign = 'center';
          ctx.fillText("Game Over!", canvas.width / 2, canvas.height / 2 + 10);
        }
        return;
      }
      // ãƒ†ãƒˆãƒªãƒŸãƒã®è‡ªå‹•è½ä¸‹å‡¦ç†
      if (isValidMove(currentPiece, 0, 1)) {
        currentPiece.y++;
      } else {
        lockPiece(currentPiece);
        clearLines();
        currentPiece = randomPiece();
        if (!isValidMove(currentPiece, 0, 0)) {
          gameOver = true;
        }
      }
      drawBoard();
      drawPiece(currentPiece);
    }

    // ã‚­ãƒ¼æ“ä½œï¼ˆâ†â†’â†“ã§ç§»å‹•ã€â†‘ã§å›è»¢ï¼‰
    document.addEventListener('keydown', function(e) {
      if (gameOver) return;
      if (e.key === 'ArrowLeft') {
        if (isValidMove(currentPiece, -1, 0)) {
          currentPiece.x--;
        }
      } else if (e.key === 'ArrowRight') {
        if (isValidMove(currentPiece, 1, 0)) {
          currentPiece.x++;
        }
      } else if (e.key === 'ArrowDown') {
        if (isValidMove(currentPiece, 0, 1)) {
          currentPiece.y++;
        }
      } else if (e.key === 'ArrowUp') {
        const rotated = rotate(currentPiece.shape);
        if (isValidMove(currentPiece, 0, 0, rotated)) {
          currentPiece.shape = rotated;
        }
      }
      drawBoard();
      drawPiece(currentPiece);
    });

    // ã‚²ãƒ¼ãƒ é–‹å§‹ï¼å†é–‹å‡¦ç†
    function startGame() {
      gameOver = false;
      score = 0;
      speedIncreased = false;
      scoreElement.textContent = score;
      messageElement.textContent = "";
      createBoard();
      currentPiece = randomPiece();
      if (gameInterval) {
        clearInterval(gameInterval);
      }
      // åˆæœŸè½ä¸‹é€Ÿåº¦ã¯500ms
      gameInterval = setInterval(gameLoop, 500);
      drawBoard();
      drawPiece(currentPiece);
    }

    startButton.addEventListener('click', startGame);
  </script>
</body>
</html>
